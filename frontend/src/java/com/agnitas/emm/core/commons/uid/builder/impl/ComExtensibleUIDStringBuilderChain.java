/*

    Copyright (C) 2022 AGNITAS AG (https://www.agnitas.org)

    This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
    You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

*/

package com.agnitas.emm.core.commons.uid.builder.impl;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Vector;

import org.agnitas.emm.core.commons.uid.builder.ExtensibleUIDStringBuilder;
import org.agnitas.emm.core.commons.uid.builder.impl.exception.RequiredInformationMissingException;
import org.agnitas.emm.core.commons.uid.builder.impl.exception.UIDStringBuilderException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.agnitas.emm.core.commons.uid.ComExtensibleUID;
import com.agnitas.emm.core.commons.uid.ExtensibleUidVersion;
import com.agnitas.emm.core.commons.uid.beans.CompanyUidData;
import com.agnitas.emm.core.commons.uid.daocache.impl.CompanyUidDataDaoCache;

public final class ComExtensibleUIDStringBuilderChain implements ExtensibleUIDStringBuilder {

	/** Logger. */
	private static final transient Logger logger = LogManager.getLogger( ComExtensibleUIDStringBuilderChain.class);
	
	// ------------------------------------------------------------------------------ Dependency Injection
	
	/** List of parsers. */
	private List<ExtensibleUIDStringBuilder> stringBuilderList = new Vector<>();
	
	/** Cache for companies. */
	private CompanyUidDataDaoCache companyUidDataCache;
	
	/** Newest UID version, that is handled by the list of string builder. */
	private ExtensibleUidVersion newestUIDVersion;

	/**
	 * Set list of parsers. 
	 * 
	 * @param list list of parsers
	 */
	public final void setStringBuilderList(final List<ExtensibleUIDStringBuilder> list) {
		this.stringBuilderList = new Vector<>(list);
	
		ExtensibleUidVersion newest = null;
		for( ExtensibleUIDStringBuilder stringBuilder : this.stringBuilderList)
			newest = ExtensibleUidVersion.newerOf(newest, stringBuilder.getVersionOfBuiltUIDs());
		
		this.newestUIDVersion = newest;
	}
	
	/**
	 * Set the CompanyDaoCache.
	 * 
	 * @param cache CompanyDaoCache
	 */
	public final void setCompanyUidDataDaoCache(final CompanyUidDataDaoCache cache) { // TODO Replace by constructor injection
		this.companyUidDataCache = Objects.requireNonNull(cache, "Cache canno tbe null");
	}
	
	// ------------------------------------------------------------------------------ Business Logic

	/**
	 * Returns the UID version enabled for given company.
	 * If version number is 0 or version number is unknown, the latest UID version is returned.
	 * 
	 * @param companyUidData UID data for company
	 * 
	 * @return UID version enabled for given company 
	 */
	private static final ExtensibleUidVersion enabledUidVersionFromCompany(final CompanyUidData companyUidData) {
		try {
			final ExtensibleUidVersion version = ExtensibleUidVersion.fromVersionNumber(companyUidData.getEnabledUIDVersion());
			
			if(version.getVersionCode() == 0) {
				return ExtensibleUidVersion.latest();
			} else {
				return version;
			}
			
		} catch(final NoSuchElementException e) {
			return ExtensibleUidVersion.latest();
		}
	}
	
	@Override
	public String buildUIDString(final ComExtensibleUID extensibleUID) throws UIDStringBuilderException, RequiredInformationMissingException {
		// Read the company for the UID to determine, which is the first string builder we try to use for UID generation.
		final CompanyUidData companyUidData = this.companyUidDataCache.getItem(extensibleUID.getCompanyID());
		
		// Determine the UID version that is enabled for this company
		final ExtensibleUidVersion enabledUidversion = enabledUidVersionFromCompany(companyUidData);
		
		if(logger.isInfoEnabled()) {
			logger.info(String.format("Company %d has UID version %s enabled", extensibleUID.getCompanyID(), enabledUidversion));
		}
		
		for(final ExtensibleUIDStringBuilder stringBuilder : this.stringBuilderList) {
			/*
			 * If company is not set to support "newest UID version" (getEnabledUIDVersion() == 0)
			 * and if version of UID generated by builder is newer than UID version supported by string builder
			 * then try next builder.
			 */
			if(stringBuilder.getVersionOfBuiltUIDs().isNewerThan(enabledUidversion)) {
				continue;
			}
				
			try {
				final String uidString = stringBuilder.buildUIDString( extensibleUID);
				
				if( uidString != null) {
					return uidString;
				} else {
					if( logger.isInfoEnabled()) {
						logger.info( "string builder " + stringBuilder.getClass().getCanonicalName() + " didn't return a UID string");
					}
				}
			} catch( RequiredInformationMissingException e) {
				if( logger.isDebugEnabled()) {
					logger.debug( "string builder " + stringBuilder.getClass().getCanonicalName() + " was not able to build UID string", e);
				} else if( logger.isInfoEnabled()) {
					logger.info( "string builder " + stringBuilder.getClass().getCanonicalName() + " was not able to build UID string");
				} 
			}
			/*
			 * Do not catch the UIDStringBuilderException here.
			 * When a string builder throws those exceptions, something
			 * went badly wrong, so that generating the UID string with
			 * an older version does not make sense.
			 */
			
			logger.info( "trying next string builder");
		}
		
		logger.error( "no string builder found");
		
		throw new UIDStringBuilderException( "could not generate UID - no matching string builder found");
	}
	
	@Override
	public ExtensibleUidVersion getVersionOfBuiltUIDs() {
		return newestUIDVersion;
	}
}
